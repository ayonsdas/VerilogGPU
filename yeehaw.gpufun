blue = 0
depth = 0


int address = 65408
red = 480 # kinda cursed, but allows keeping the condition without allocating a new register
st address, red
deli address
vec zero = 0
gt red, red, zero
delv zero

while(red){



    ///////////////////////////
    // triangle 1
    ///////////////////////////

    int triCount = 10
    int triIndex = 0
    lts triCount, triIndex, triCount # triCount = (bool) triIndex < triCount
    vec triCountBool = 0
    triCountBool = triCount
    deli triCount
    while(triCountBool){
        /////////////////////////////////
        // matrix multiplication to update vertex positions and normals
        /////////////////////////////////
        int address1 = 48000
        # account for triangle index
        int triangleAddressOffset = 768
        muls triangleAddressOffset, triangleAddressOffset, triIndex
        adds address1, address1, triangleAddressOffset
        deli triangleAddressOffset
        int addressMatrix = 40000
        int step = 32
        # load x, y, z of vertex 1
        vec vx = 0
        ld vx, address1
        adds address1, address1, step
        vec vy = 0
        ld vy, address1
        adds address1, address1, step
        vec vz = 0
        ld vz, address1
        adds address1, address1, step
        # result vector
        vec vrx = 0
        vec vry = 0
        vec vrz = 0

        # matrix-vector multipication
        vec m = 0
        vec temp = 0
        # vrx += m00 * vx
        ld m, addressMatrix
        mul temp, m, vx
        add vrx, vrx, temp
        adds addressMatrix, addressMatrix, step
        # vrx += m01 * vy
        ld m, addressMatrix
        mul temp, m, vy
        add vrx, vrx, temp
        adds addressMatrix, addressMatrix, step
        # vrx += m02 * vz
        ld m, addressMatrix
        mul temp, m, vz
        add vrx, vrx, temp
        adds addressMatrix, addressMatrix, step
        # vry += m10 * vx
        ld m, addressMatrix
        mul temp, m, vx
        add vry, vry, temp
        adds addressMatrix, addressMatrix, step
        # vry += m11 * vy
        ld m, addressMatrix
        mul temp, m, vy
        add vry, vry, temp
        adds addressMatrix, addressMatrix, step
        # vry += m12 * vz
        ld m, addressMatrix
        mul temp, m, vz
        add vry, vry, temp
        adds addressMatrix, addressMatrix, step
        # vrz += m20 * vx
        ld m, addressMatrix
        mul temp, m, vx
        add vrz, vrz, temp
        adds addressMatrix, addressMatrix, step
        # vrz += m21 * vy
        ld m, addressMatrix
        mul temp, m, vy
        add vrz, vrz, temp
        adds addressMatrix, addressMatrix, step
        # vrz += m22 * vz
        ld m, addressMatrix
        mul temp, m, vz
        add vrz, vrz, temp
        adds addressMatrix, addressMatrix, step
        delv m
        delv temp


        # write result
        address1 = 48000
        int triangleAddressOffset = 768
        muls triangleAddressOffset, triangleAddressOffset, triIndex
        adds address1, address1, triangleAddressOffset
        deli triangleAddressOffset
        st address1, vrx
        adds address1, address1, step
        st address1, vry
        adds address1, address1, step
        st address1, vrz
        adds address1, address1, step

        delv vx
        delv vy
        delv vz
        delv vrx
        delv vry
        delv vrz
        deli addressMatrix
        deli address1
        deli step

        // vertex 2
        int address1 = 48096
        # account for triangle index
        int triangleAddressOffset = 768
        muls triangleAddressOffset, triangleAddressOffset, triIndex
        adds address1, address1, triangleAddressOffset
        deli triangleAddressOffset
        int addressMatrix = 40000
        int step = 32
        # load x, y, z of vertex 1
        vec vx = 0
        ld vx, address1
        adds address1, address1, step
        vec vy = 0
        ld vy, address1
        adds address1, address1, step
        vec vz = 0
        ld vz, address1
        adds address1, address1, step
        # result vector
        vec vrx = 0
        vec vry = 0
        vec vrz = 0

        # matrix-vector multipication
        vec m = 0
        vec temp = 0
        # vrx += m00 * vx
        ld m, addressMatrix
        mul temp, m, vx
        add vrx, vrx, temp
        adds addressMatrix, addressMatrix, step
        # vrx += m01 * vy
        ld m, addressMatrix
        mul temp, m, vy
        add vrx, vrx, temp
        adds addressMatrix, addressMatrix, step
        # vrx += m02 * vz
        ld m, addressMatrix
        mul temp, m, vz
        add vrx, vrx, temp
        adds addressMatrix, addressMatrix, step
        # vry += m10 * vx
        ld m, addressMatrix
        mul temp, m, vx
        add vry, vry, temp
        adds addressMatrix, addressMatrix, step
        # vry += m11 * vy
        ld m, addressMatrix
        mul temp, m, vy
        add vry, vry, temp
        adds addressMatrix, addressMatrix, step
        # vry += m12 * vz
        ld m, addressMatrix
        mul temp, m, vz
        add vry, vry, temp
        adds addressMatrix, addressMatrix, step
        # vrz += m20 * vx
        ld m, addressMatrix
        mul temp, m, vx
        add vrz, vrz, temp
        adds addressMatrix, addressMatrix, step
        # vrz += m21 * vy
        ld m, addressMatrix
        mul temp, m, vy
        add vrz, vrz, temp
        adds addressMatrix, addressMatrix, step
        # vrz += m22 * vz
        ld m, addressMatrix
        mul temp, m, vz
        add vrz, vrz, temp
        adds addressMatrix, addressMatrix, step
        delv m
        delv temp


        # write result
        address1 = 48096
        int triangleAddressOffset = 768
        muls triangleAddressOffset, triangleAddressOffset, triIndex
        adds address1, address1, triangleAddressOffset
        deli triangleAddressOffset
        st address1, vrx
        adds address1, address1, step
        st address1, vry
        adds address1, address1, step
        st address1, vrz
        adds address1, address1, step

        delv vx
        delv vy
        delv vz
        delv vrx
        delv vry
        delv vrz
        deli addressMatrix
        deli address1
        deli step

        // vertex 3
        int address1 = 48192
        # account for triangle index
        int triangleAddressOffset = 768
        muls triangleAddressOffset, triangleAddressOffset, triIndex
        adds address1, address1, triangleAddressOffset
        deli triangleAddressOffset
        int addressMatrix = 40000
        int step = 32
        # load x, y, z of vertex 1
        vec vx = 0
        ld vx, address1
        adds address1, address1, step
        vec vy = 0
        ld vy, address1
        adds address1, address1, step
        vec vz = 0
        ld vz, address1
        adds address1, address1, step
        # result vector
        vec vrx = 0
        vec vry = 0
        vec vrz = 0

        # matrix-vector multipication
        vec m = 0
        vec temp = 0
        # vrx += m00 * vx
        ld m, addressMatrix
        mul temp, m, vx
        add vrx, vrx, temp
        adds addressMatrix, addressMatrix, step
        # vrx += m01 * vy
        ld m, addressMatrix
        mul temp, m, vy
        add vrx, vrx, temp
        adds addressMatrix, addressMatrix, step
        # vrx += m02 * vz
        ld m, addressMatrix
        mul temp, m, vz
        add vrx, vrx, temp
        adds addressMatrix, addressMatrix, step
        # vry += m10 * vx
        ld m, addressMatrix
        mul temp, m, vx
        add vry, vry, temp
        adds addressMatrix, addressMatrix, step
        # vry += m11 * vy
        ld m, addressMatrix
        mul temp, m, vy
        add vry, vry, temp
        adds addressMatrix, addressMatrix, step
        # vry += m12 * vz
        ld m, addressMatrix
        mul temp, m, vz
        add vry, vry, temp
        adds addressMatrix, addressMatrix, step
        # vrz += m20 * vx
        ld m, addressMatrix
        mul temp, m, vx
        add vrz, vrz, temp
        adds addressMatrix, addressMatrix, step
        # vrz += m21 * vy
        ld m, addressMatrix
        mul temp, m, vy
        add vrz, vrz, temp
        adds addressMatrix, addressMatrix, step
        # vrz += m22 * vz
        ld m, addressMatrix
        mul temp, m, vz
        add vrz, vrz, temp
        adds addressMatrix, addressMatrix, step
        delv m
        delv temp


        # write result
        address1 = 48192
        int triangleAddressOffset = 768
        muls triangleAddressOffset, triangleAddressOffset, triIndex
        adds address1, address1, triangleAddressOffset
        deli triangleAddressOffset
        st address1, vrx
        adds address1, address1, step
        st address1, vry
        adds address1, address1, step
        st address1, vrz
        adds address1, address1, step

        delv vx
        delv vy
        delv vz
        delv vrx
        delv vry
        delv vrz
        deli addressMatrix
        deli address1
        deli step





        // // do normals this time
        // /////////////////////////////////
        // // matrix multiplication to update vertex positions and normals
        // /////////////////////////////////
        // int address1 = 48480
        // # account for triangle index
        // int triangleAddressOffset = 768
        // muls triangleAddressOffset, triangleAddressOffset, triIndex
        // adds address1, address1, triangleAddressOffset
        // deli triangleAddressOffset
        // int addressMatrix = 40000
        // int step = 32
        // # load x, y, z of vertex 1
        // vec vx = 0
        // ld vx, address1
        // adds address1, address1, step
        // vec vy = 0
        // ld vy, address1
        // adds address1, address1, step
        // vec vz = 0
        // ld vz, address1
        // adds address1, address1, step
        // # result vector
        // vec vrx = 0
        // vec vry = 0
        // vec vrz = 0

        // # matrix-vector multipication
        // vec m = 0
        // vec temp = 0
        // # vrx += m00 * vx
        // ld m, addressMatrix
        // mul temp, m, vx
        // add vrx, vrx, temp
        // adds addressMatrix, addressMatrix, step
        // # vrx += m01 * vy
        // ld m, addressMatrix
        // mul temp, m, vy
        // add vrx, vrx, temp
        // adds addressMatrix, addressMatrix, step
        // # vrx += m02 * vz
        // ld m, addressMatrix
        // mul temp, m, vz
        // add vrx, vrx, temp
        // adds addressMatrix, addressMatrix, step
        // # vry += m10 * vx
        // ld m, addressMatrix
        // mul temp, m, vx
        // add vry, vry, temp
        // adds addressMatrix, addressMatrix, step
        // # vry += m11 * vy
        // ld m, addressMatrix
        // mul temp, m, vy
        // add vry, vry, temp
        // adds addressMatrix, addressMatrix, step
        // # vry += m12 * vz
        // ld m, addressMatrix
        // mul temp, m, vz
        // add vry, vry, temp
        // adds addressMatrix, addressMatrix, step
        // # vrz += m20 * vx
        // ld m, addressMatrix
        // mul temp, m, vx
        // add vrz, vrz, temp
        // adds addressMatrix, addressMatrix, step
        // # vrz += m21 * vy
        // ld m, addressMatrix
        // mul temp, m, vy
        // add vrz, vrz, temp
        // adds addressMatrix, addressMatrix, step
        // # vrz += m22 * vz
        // ld m, addressMatrix
        // mul temp, m, vz
        // add vrz, vrz, temp
        // adds addressMatrix, addressMatrix, step
        // delv m
        // delv temp


        // # write result
        // address1 = 48480
        // int triangleAddressOffset = 768
        // muls triangleAddressOffset, triangleAddressOffset, triIndex
        // adds address1, address1, triangleAddressOffset
        // deli triangleAddressOffset
        // st address1, vrx
        // adds address1, address1, step
        // st address1, vry
        // adds address1, address1, step
        // st address1, vrz
        // adds address1, address1, step

        // delv vx
        // delv vy
        // delv vz
        // delv vrx
        // delv vry
        // delv vrz
        // deli addressMatrix
        // deli address1
        // deli step

        // // vertex 2
        // int address1 = 48576
        // # account for triangle index
        // int triangleAddressOffset = 768
        // muls triangleAddressOffset, triangleAddressOffset, triIndex
        // adds address1, address1, triangleAddressOffset
        // deli triangleAddressOffset
        // int addressMatrix = 40000
        // int step = 32
        // # load x, y, z of vertex 1
        // vec vx = 0
        // ld vx, address1
        // adds address1, address1, step
        // vec vy = 0
        // ld vy, address1
        // adds address1, address1, step
        // vec vz = 0
        // ld vz, address1
        // adds address1, address1, step
        // # result vector
        // vec vrx = 0
        // vec vry = 0
        // vec vrz = 0

        // # matrix-vector multipication
        // vec m = 0
        // vec temp = 0
        // # vrx += m00 * vx
        // ld m, addressMatrix
        // mul temp, m, vx
        // add vrx, vrx, temp
        // adds addressMatrix, addressMatrix, step
        // # vrx += m01 * vy
        // ld m, addressMatrix
        // mul temp, m, vy
        // add vrx, vrx, temp
        // adds addressMatrix, addressMatrix, step
        // # vrx += m02 * vz
        // ld m, addressMatrix
        // mul temp, m, vz
        // add vrx, vrx, temp
        // adds addressMatrix, addressMatrix, step
        // # vry += m10 * vx
        // ld m, addressMatrix
        // mul temp, m, vx
        // add vry, vry, temp
        // adds addressMatrix, addressMatrix, step
        // # vry += m11 * vy
        // ld m, addressMatrix
        // mul temp, m, vy
        // add vry, vry, temp
        // adds addressMatrix, addressMatrix, step
        // # vry += m12 * vz
        // ld m, addressMatrix
        // mul temp, m, vz
        // add vry, vry, temp
        // adds addressMatrix, addressMatrix, step
        // # vrz += m20 * vx
        // ld m, addressMatrix
        // mul temp, m, vx
        // add vrz, vrz, temp
        // adds addressMatrix, addressMatrix, step
        // # vrz += m21 * vy
        // ld m, addressMatrix
        // mul temp, m, vy
        // add vrz, vrz, temp
        // adds addressMatrix, addressMatrix, step
        // # vrz += m22 * vz
        // ld m, addressMatrix
        // mul temp, m, vz
        // add vrz, vrz, temp
        // adds addressMatrix, addressMatrix, step
        // delv m
        // delv temp


        // # write result
        // address1 = 48576
        // int triangleAddressOffset = 768
        // muls triangleAddressOffset, triangleAddressOffset, triIndex
        // adds address1, address1, triangleAddressOffset
        // deli triangleAddressOffset
        // st address1, vrx
        // adds address1, address1, step
        // st address1, vry
        // adds address1, address1, step
        // st address1, vrz
        // adds address1, address1, step

        // delv vx
        // delv vy
        // delv vz
        // delv vrx
        // delv vry
        // delv vrz
        // deli addressMatrix
        // deli address1
        // deli step

        // // vertex 3
        // int address1 = 48672
        // # account for triangle index
        // int triangleAddressOffset = 768
        // muls triangleAddressOffset, triangleAddressOffset, triIndex
        // adds address1, address1, triangleAddressOffset
        // deli triangleAddressOffset
        // int addressMatrix = 40000
        // int step = 32
        // # load x, y, z of vertex 1
        // vec vx = 0
        // ld vx, address1
        // adds address1, address1, step
        // vec vy = 0
        // ld vy, address1
        // adds address1, address1, step
        // vec vz = 0
        // ld vz, address1
        // adds address1, address1, step
        // # result vector
        // vec vrx = 0
        // vec vry = 0
        // vec vrz = 0

        // # matrix-vector multipication
        // vec m = 0
        // vec temp = 0
        // # vrx += m00 * vx
        // ld m, addressMatrix
        // mul temp, m, vx
        // add vrx, vrx, temp
        // adds addressMatrix, addressMatrix, step
        // # vrx += m01 * vy
        // ld m, addressMatrix
        // mul temp, m, vy
        // add vrx, vrx, temp
        // adds addressMatrix, addressMatrix, step
        // # vrx += m02 * vz
        // ld m, addressMatrix
        // mul temp, m, vz
        // add vrx, vrx, temp
        // adds addressMatrix, addressMatrix, step
        // # vry += m10 * vx
        // ld m, addressMatrix
        // mul temp, m, vx
        // add vry, vry, temp
        // adds addressMatrix, addressMatrix, step
        // # vry += m11 * vy
        // ld m, addressMatrix
        // mul temp, m, vy
        // add vry, vry, temp
        // adds addressMatrix, addressMatrix, step
        // # vry += m12 * vz
        // ld m, addressMatrix
        // mul temp, m, vz
        // add vry, vry, temp
        // adds addressMatrix, addressMatrix, step
        // # vrz += m20 * vx
        // ld m, addressMatrix
        // mul temp, m, vx
        // add vrz, vrz, temp
        // adds addressMatrix, addressMatrix, step
        // # vrz += m21 * vy
        // ld m, addressMatrix
        // mul temp, m, vy
        // add vrz, vrz, temp
        // adds addressMatrix, addressMatrix, step
        // # vrz += m22 * vz
        // ld m, addressMatrix
        // mul temp, m, vz
        // add vrz, vrz, temp
        // adds addressMatrix, addressMatrix, step
        // delv m
        // delv temp


        // # write result
        // address1 = 48672
        // int triangleAddressOffset = 768
        // muls triangleAddressOffset, triangleAddressOffset, triIndex
        // adds address1, address1, triangleAddressOffset
        // deli triangleAddressOffset
        // st address1, vrx
        // adds address1, address1, step
        // st address1, vry
        // adds address1, address1, step
        // st address1, vrz
        // adds address1, address1, step

        // delv vx
        // delv vy
        // delv vz
        // delv vrx
        // delv vry
        // delv vrz
        // deli addressMatrix
        // deli address1
        // deli step









        int address1 = 48000
        # account for triangle index
        int triangleAddressOffset = 768
        muls triangleAddressOffset, triangleAddressOffset, triIndex
        adds address1, address1, triangleAddressOffset
        deli triangleAddressOffset

        int step = 32
        vec memVec = 0
        vec zVec = 0
        vec zScale = 256
        vec zOffset = 512
        int zAddress = 0
        adds zAddress, address1, step
        adds zAddress, zAddress, step # zAddress = address1 + 2 * step
        ld zVec, zAddress # first z value
        sub zVec, zOffset, zVec
        div zVec, zVec, zScale
        vec pixelOffset = 128
        
        # first vertex
        int t1x1s = 0
        ld memVec, address1
        div memVec, memVec, zVec
        # store w value
        int addressW = 64192 # addressNorm to store temporary normal
        vec wVex = 1
        div wVex, wVex, zVec # w = 1/z
        st addressW, wVex
        deli addressW
        delv wVex
        # end store w value
        add memVec, memVec, pixelOffset
        movpart t1x1s, memVec
        adds address1, address1, step
        int t1y1s = 0
        ld memVec, address1
        div memVec, memVec, zVec
        add memVec, memVec, pixelOffset
        movpart t1y1s, memVec

        # second vertex
        adds zAddress, zAddress, step
        adds zAddress, zAddress, step
        adds zAddress, zAddress, step
        ld zVec, zAddress # second z value
        sub zVec, zOffset, zVec
        div zVec, zVec, zScale
        adds address1, address1, step
        adds address1, address1, step
        int t1x2s = 0
        ld memVec, address1
        div memVec, memVec, zVec
        # store w value
        int addressW = 64224 # addressNorm to store temporary normal
        vec wVex = 1
        div wVex, wVex, zVec # w = 1/z
        st addressW, wVex
        deli addressW
        delv wVex
        # end store w value
        add memVec, memVec, pixelOffset
        movpart t1x2s, memVec
        adds address1, address1, step
        int t1y2s = 0
        ld memVec, address1
        div memVec, memVec, zVec
        add memVec, memVec, pixelOffset
        movpart t1y2s, memVec

        # third vertex
        adds zAddress, zAddress, step
        adds zAddress, zAddress, step
        adds zAddress, zAddress, step
        ld zVec, zAddress # third z value
        sub zVec, zOffset, zVec
        div zVec, zVec, zScale
        adds address1, address1, step
        adds address1, address1, step
        int t1x3s = 0
        ld memVec, address1
        div memVec, memVec, zVec
        # store w value
        int addressW = 64256 # addressNorm to store temporary normal
        vec wVex = 1
        div wVex, wVex, zVec # w = 1/z
        st addressW, wVex
        deli addressW
        delv wVex
        # end store w value
        add memVec, memVec, pixelOffset
        movpart t1x3s, memVec
        adds address1, address1, step
        int t1y3s = 0
        ld memVec, address1
        div memVec, memVec, zVec
        add memVec, memVec, pixelOffset
        movpart t1y3s, memVec

        deli address1
        deli step
        delv memVec
        delv pixelOffset
        delv zVec
        delv zScale
        delv zOffset
        deli zAddress

        # find max x
        int zeroi = 0
        int maxX = 0
        adds maxX, zeroi, t1x1s
        int challenge = 0
        adds challenge, zeroi, t1x2s
        int booli = 0
        vec bool = 0

        gts booli, challenge, maxX
        bool = booli 
        if(bool){
            adds maxX, zeroi, challenge
        }
        adds challenge, zeroi, t1x3s
        gts booli, challenge, maxX
        bool = booli
        if(bool){
            adds maxX, zeroi, challenge
        }

        # find max y
        int maxY = 0
        adds maxY, zeroi, t1y1s
        adds challenge, zeroi, t1y2s
        gts booli, challenge, maxY
        bool = booli
        if(bool){
            adds maxY, zeroi, challenge
        }
        adds challenge, zeroi, t1y3s
        gts booli, challenge, maxY
        bool = booli
        if(bool){
            adds maxY, zeroi, challenge
        }

        # find min x
        int minX = 0
        adds minX, zeroi, t1x1s
        adds challenge, zeroi, t1x2s
        lts booli, challenge, minX
        bool = booli
        if(bool){
            adds minX, zeroi, challenge
        }
        adds challenge, zeroi, t1x3s
        lts booli, challenge, minX
        bool = booli
        if(bool){
            adds minX, zeroi, challenge
        }

        # find min y
        int minY = 0
        adds minY, zeroi, t1y1s
        adds challenge, zeroi, t1y2s
        lts booli, challenge, minY
        bool = booli
        if(bool){
            adds minY, zeroi, challenge
        }
        adds challenge, zeroi, t1y3s
        lts booli, challenge, minY
        bool = booli
        if(bool){
            adds minY, zeroi, challenge
        }

        # clean up
        deli zeroi
        deli challenge
        deli booli
        delv bool


        // x = minX
        x = 0
        y = 0
        int zeroi = 0
        adds x, zeroi, minX
        adds y, zeroi, minY
        deli zeroi
        // y = minY
        // int increment = 32 # amount to increment
        // int yIncrement = 1 # amount to increment y


        vec t1maxY = 0
        t1maxY = maxY
        // vec yV = 0
        // yV = y
        green = y
        vec yInBound = 0
        lte yInBound, green, t1maxY # yInBound = (bool) y < 255
        delv t1maxY
        while(yInBound){
            
            // x = minX
            int zeroi = 0
            adds x, zeroi, minX
            deli zeroi

            vec xV = 0
            vec threadId = 0
            vec xInBound = 0
            xV = x
            movidx threadId # threadId = thread index
            add xV, xV, threadId # xV = x + thread index
            vec t1maxX = 0
            t1maxX = maxX
            lte xInBound, xV, t1maxX
            delv t1maxX
            delv threadId
            while(xInBound){
                // vec scale255 = 255
                // div red, xV, scale255
                green = y
                // div green, green, scale255
                // delv scale255

                # vec threadLower = 0
                # vec halfThread = 8
                # lt threadLower, threadId, halfThread # threadLower = (bool) threadId <= 16
                # # make blue if thread index is less than 16
                # if(threadLower){
                #     blue = 1
                # } else {
                #     blue = 0
                # }
                # we are going to mask by barycentric weight
                pushmask

                # compute vertex weights per pixel
                # get vertex 1 and 2
                vec tx1 = 0
                tx1 = t1x1s
                vec ty1 = 0
                ty1 = t1y1s
                vec tx2 = 0
                tx2 = t1x2s
                vec ty2 = 0
                ty2 = t1y2s
                # compute barycentric weight
                # formula: (bx-ax)(cy-ay) - (by-ay)(cx-ax)
                # let a = (tx1, ty1)
                # let b = (tx2, ty2)
                # let c = (xV, yV)
                vec bx_ax = 0 # bx-ax
                # bx_ax = tx2 - tx1
                sub bx_ax, tx2, tx1
                vec cy_ay = 0 # cy-ay
                # cy_ay = yV - ty1
                sub cy_ay, green, ty1
                vec barycentricWeight = 0
                # barycentricWeight = bx_ax * cy_ay
                mul barycentricWeight, bx_ax, cy_ay
                delv bx_ax
                delv cy_ay
                vec by_ay = 0 # by-ay
                # by_ay = ty2 - ty1
                sub by_ay, ty2, ty1
                vec cx_ax = 0 # cx-ax
                # cx_ax = xV - tx1
                sub cx_ax, xV, tx1
                # barycentricWeight = barycentricWeight - by_ay * cx_ax
                vec temp = 0
                mul temp, by_ay, cx_ax
                sub barycentricWeight, barycentricWeight, temp
                delv by_ay
                delv cx_ax
                delv temp
                delv tx1
                delv ty1
                delv tx2
                delv ty2

                # store barycentric weight in specified location so we can use it later
                # address to store barycentric weight
                int address2 = 64000
                st address2, barycentricWeight
                # for now, just mask on barycentric weight is positive
                vec zero = 0
                # reuse barycentricWeight as bool
                gte barycentricWeight, barycentricWeight, zero
                andmask barycentricWeight
                delv zero
                delv barycentricWeight
                deli address2

                # the second barycentric weight
                # get vertex 2 and 3
                vec tx2 = t1x2s
                vec ty2 = t1y2s
                vec tx3 = t1x3s
                vec ty3 = t1y3s
                # compute barycentric weight
                # formula: (bx-ax)(cy-ay) - (by-ay)(cx-ax)
                # let a = (tx2, ty2)
                # let b = (tx3, ty3)
                # let c = (xV, yV)
                vec bx_ax = 0 # bx-ax
                # bx_ax = tx3 - tx2
                sub bx_ax, tx3, tx2
                vec cy_ay = 0 # cy-ay
                # cy_ay = yV - ty2
                sub cy_ay, green, ty2
                vec barycentricWeight2 = 0
                # barycentricWeight2 = bx_ax * cy_ay
                mul barycentricWeight2, bx_ax, cy_ay
                delv bx_ax
                delv cy_ay
                vec by_ay = 0 # by-ay
                # by_ay = ty3 - ty2
                sub by_ay, ty3, ty2
                vec cx_ax = 0 # cx-ax
                # cx_ax = xV - tx2
                sub cx_ax, xV, tx2
                # barycentricWeight2 = barycentricWeight2 - by_ay * cx_ax
                vec temp = 0
                mul temp, by_ay, cx_ax
                sub barycentricWeight2, barycentricWeight2, temp
                delv by_ay
                delv cx_ax
                delv temp
                delv tx2
                delv ty2
                delv tx3
                delv ty3


                # store barycentric weight in specified location so we can use it later
                # address2 to store barycentric weight
                int address2 = 64032
                st address2, barycentricWeight2
                # for now, just mask on barycentric weight is positive
                vec zero = 0
                # reuse barycentricWeight as bool
                gte barycentricWeight2, barycentricWeight2, zero
                andmask barycentricWeight2
                delv zero
                delv barycentricWeight2
                deli address2


                # the third barycentric weight
                # get vertex 3 and 1
                vec tx3 = t1x3s
                vec ty3 = t1y3s
                vec tx1 = t1x1s
                vec ty1 = t1y1s
                # compute barycentric weight
                # formula: (bx-ax)(cy-ay) - (by-ay)(cx-ax)
                # let a = (tx3, ty3)
                # let b = (tx1, ty1)
                # let c = (xV, yV)
                vec bx_ax = 0 # bx-ax
                # bx_ax = tx1 - tx3
                sub bx_ax, tx1, tx3
                vec cy_ay = 0 # cy-ay
                # cy_ay = yV - ty3
                sub cy_ay, green, ty3
                vec barycentricWeight3 = 0
                # barycentricWeight3 = bx_ax * cy_ay
                mul barycentricWeight3, bx_ax, cy_ay
                delv bx_ax
                delv cy_ay
                vec by_ay = 0 # by-ay
                # by_ay = ty1 - ty3
                sub by_ay, ty1, ty3
                vec cx_ax = 0 # cx-ax
                # cx_ax = xV - tx3
                sub cx_ax, xV, tx3
                # barycentricWeight3 = barycentricWeight3 - by_ay * cx_ax
                vec temp = 0
                mul temp, by_ay, cx_ax
                sub barycentricWeight3, barycentricWeight3, temp
                delv by_ay
                delv cx_ax
                delv temp
                delv tx3
                delv ty3
                delv tx1
                delv ty1

                # store barycentric weight in specified location so we can use it later
                # address2 to store barycentric weight
                int address2 = 64064
                st address2, barycentricWeight3
                # for now, just mask on barycentric weight is positive
                vec zero = 0
                # reuse barycentricWeight as bool
                gte barycentricWeight3, barycentricWeight3, zero
                andmask barycentricWeight3
                delv zero
                delv barycentricWeight3
                deli address2


                # load barycentric weights
                int address2 = 64000
                vec barycentricWeight = 0
                ld barycentricWeight, address2
                address2 = 64032
                vec barycentricWeight2 = 0
                ld barycentricWeight2, address2
                address2 = 64064
                vec barycentricWeight3 = 0
                ld barycentricWeight3, address2
                deli address2

                # context:
                // # store w value
                // int addressW = 64192 # addressNorm to store temporary normal
                // vec wVex = 1
                // div wVex, wVex, zVec # w = 1/z
                // st wVex, addressW
                // delv addressW
                // delv wVex
                // # end store w value
                # compute weighted W
                // vec wAccumulator = 0
                int addressW = 64192 # addressNorm to store temporary normal
                vec wVec = 0
                ld wVec, addressW
                mul barycentricWeight2, wVec, barycentricWeight2
                // add wAccumulator, wAccumulator, wVec
                addressW = 64224 # addressNorm to store temporary normal
                ld wVec, addressW
                mul barycentricWeight3, wVec, barycentricWeight3
                // add wAccumulator, wAccumulator, wVec
                addressW = 64256 # addressNorm to store temporary normal
                ld wVec, addressW
                mul barycentricWeight, wVec, barycentricWeight
                // add wAccumulator, wAccumulator, wVec
                delv wVec
                deli addressW
                # end compute weighted W

                vec totalweight = 0
                add totalweight, barycentricWeight, barycentricWeight2
                add totalweight, totalweight, barycentricWeight3

                # normalize barycentric weights
                div barycentricWeight, barycentricWeight, totalweight
                div barycentricWeight2, barycentricWeight2, totalweight
                div barycentricWeight3, barycentricWeight3, totalweight
                delv totalweight

                # don't need xV and yV anymore
                delv xV
                // delv yV

                // // # make green color equal first barycentric weight. Note: green is already defined
                vec zero = 0
                // add red, zero, barycentricWeight
                # vertex texture coordinates
                int addressTex = 48288
                # account for triangle index
                int triangleAddressOffset = 768
                muls triangleAddressOffset, triangleAddressOffset, triIndex
                adds addressTex, addressTex, triangleAddressOffset
                deli triangleAddressOffset
                int step = 32

                vec texX1 = 0
                ld texX1, addressTex
                adds addressTex, addressTex, step
                vec texX2 = 0
                ld texX2, addressTex
                adds addressTex, addressTex, step
                vec texX3 = 0
                ld texX3, addressTex
                adds addressTex, addressTex, step
                mul texX1, texX1, barycentricWeight2
                mul texX2, texX2, barycentricWeight3
                mul texX3, texX3, barycentricWeight
                add texX1, texX1, texX2
                add texX1, texX1, texX3
                # at this point, texX1 = barycentricWeight * texX1 + barycentricWeight2 * texX2 + barycentricWeight3 * texX3
                delv texX2
                delv texX3
                # now do y
                vec texY1 = 0
                ld texY1, addressTex
                adds addressTex, addressTex, step
                vec texY2 = 0
                ld texY2, addressTex
                adds addressTex, addressTex, step
                vec texY3 = 0
                ld texY3, addressTex
                adds addressTex, addressTex, step
                deli step
                deli addressTex
                mul texY1, texY1, barycentricWeight2
                mul texY2, texY2, barycentricWeight3
                mul texY3, texY3, barycentricWeight
                add texY1, texY1, texY2
                add texY1, texY1, texY3
                # at this point, texY1 = barycentricWeight * texY1 + barycentricWeight2 * texY2 + barycentricWeight3 * texY3
                delv texY2
                delv texY3
                # now get the texture color
                # ldtex32 rt, ra, rb, s_ra //rt[i] = mem[s_ra+round(ra[i])+32*round(rb[i])]
                # rt = red because we are loading red right now
                # ra = texX1
                # rb = texY1
                # s_ra = texture address

                // # apply W to UVs
                // div texX1, texX1, wAccumulator
                // div texY1, texY1, wAccumulator


                int textureAddress = 32000 # hard coded for now
                ldtex32 red, texX1, texY1, textureAddress
                textureAddress = 33024 # hard coded for now
                ldtex32 green, texX1, texY1, textureAddress
                textureAddress = 34048 # hard coded for now
                ldtex32 blue, texX1, texY1, textureAddress

                delv zero
                // deli address
                deli textureAddress

                // normals

                // // // # make green color equal first barycentric weight. Note: green is already defined
                // vec zero = 0
                // // add red, zero, barycentricWeight
                # normal address offset
                int addressNorm = 48480
                # account for triangle index
                int triangleAddressOffset = 768
                muls triangleAddressOffset, triangleAddressOffset, triIndex
                adds addressNorm, addressNorm, triangleAddressOffset
                deli triangleAddressOffset
                int step = 32

                vec nX1 = 0
                ld nX1, addressNorm
                adds addressNorm, addressNorm, step
                vec nX2 = 0
                ld nX2, addressNorm
                adds addressNorm, addressNorm, step
                vec nX3 = 0
                ld nX3, addressNorm
                adds addressNorm, addressNorm, step
                mul nX1, nX1, barycentricWeight2
                mul nX2, nX2, barycentricWeight3
                mul nX3, nX3, barycentricWeight
                add nX1, nX1, nX2
                add nX1, nX1, nX3
                # at this point, nX1 = barycentricWeight * nX1 + barycentricWeight2 * nX2 + barycentricWeight3 * nX3
                addressNorm = 64096 # addressNorm to store temporary normal
                st addressNorm, nX1

                addressNorm = 48480
                # account for triangle index
                int triangleAddressOffset = 768
                muls triangleAddressOffset, triangleAddressOffset, triIndex
                adds addressNorm, addressNorm, triangleAddressOffset
                deli triangleAddressOffset

                # now do y, but reuse nX... 
                ld nX1, addressNorm
                adds addressNorm, addressNorm, step
                ld nX2, addressNorm
                adds addressNorm, addressNorm, step
                ld nX3, addressNorm
                adds addressNorm, addressNorm, step
                mul nX1, nX1, barycentricWeight2
                mul nX2, nX2, barycentricWeight3
                mul nX3, nX3, barycentricWeight
                add nX1, nX1, nX2
                add nX1, nX1, nX3
                # at this point, nX1 = barycentricWeight * nX1 + barycentricWeight2 * nX2 + barycentricWeight3 * nX3
                addressNorm = 64128 # addressNorm to store temporary normal
                st addressNorm, nX1

                addressNorm = 48480
                # account for triangle index
                int triangleAddressOffset = 768
                muls triangleAddressOffset, triangleAddressOffset, triIndex
                adds addressNorm, addressNorm, triangleAddressOffset
                deli triangleAddressOffset

                # now do z, but reuse nX...
                ld nX1, addressNorm
                adds addressNorm, addressNorm, step
                ld nX2, addressNorm
                adds addressNorm, addressNorm, step
                ld nX3, addressNorm
                adds addressNorm, addressNorm, step
                mul nX1, nX1, barycentricWeight2
                mul nX2, nX2, barycentricWeight3
                mul nX3, nX3, barycentricWeight
                add nX1, nX1, nX2
                add nX1, nX1, nX3
                # at this point, nX1 = barycentricWeight * nX1 + barycentricWeight2 * nX2 + barycentricWeight3 * nX3
                addressNorm = 64160 # addressNorm to store temporary normal
                st addressNorm, nX1
                deli addressNorm

                deli step
                delv nX1
                delv nX2
                delv nX3


                

                delv barycentricWeight
                delv barycentricWeight2
                delv barycentricWeight3

                # apply lighting
                # get light direction
                vec lightAccumulator = 0
                vec lightDirectionX = 0
                vec nX1 = 0
                int address = 64096 # read from temporary normal
                ld nX1, address
                address = 47904
                ld lightDirectionX, address
                mul lightDirectionX, lightDirectionX, nX1
                add lightAccumulator, lightAccumulator, lightDirectionX
                # reuse variables for y
                address = 64128 # read from temporary normal
                ld nX1, address
                address = 47936
                ld lightDirectionX, address
                mul lightDirectionX, lightDirectionX, nX1
                add lightAccumulator, lightAccumulator, lightDirectionX
                # reuse variables for z
                address = 64160 # read from temporary normal
                ld nX1, address
                address = 47968
                ld lightDirectionX, address
                mul lightDirectionX, lightDirectionX, nX1
                add lightAccumulator, lightAccumulator, lightDirectionX
                # clean up
                delv lightDirectionX
                delv nX1
                deli address

                # weigh lighting 0.85 and ambient is the rest
                vec mulValue = 0.25
                mul lightAccumulator, lightAccumulator, mulValue
                delv mulValue
                vec ambient = 0.75
                add lightAccumulator, lightAccumulator, ambient
                delv ambient

                # apply lighting to color
                mul red, red, lightAccumulator
                mul green, green, lightAccumulator
                mul blue, blue, lightAccumulator
                delv lightAccumulator
                
                // vec i = 0
                // delv i
                wrscreen # write pixel

                # restore the mask before barycentric weight masking
                popmask

                // increment x
                int increment = 32
                adds x, x, increment
                deli increment
                vec xV = 0
                xV = x
                vec threadId = 0
                movidx threadId # threadId = thread index
                add xV, xV, threadId # xV = x + thread index
                vec t1maxX = 0
                t1maxX = maxX
                lte xInBound, xV, t1maxX
                delv t1maxX
                delv threadId
            }

            // increment y
            int yIncrement = 1
            adds y, y, yIncrement
            deli yIncrement
            // vec yV = 0
            green = y
            vec t1maxY = 0
            t1maxY = maxY
            lte yInBound, green, t1maxY # yInBound = (bool) y < 255
            delv t1maxY
        }

        int triCount = 10
        int triIncrement = 1
        adds triIndex, triIndex, triIncrement
        deli triIncrement
        lts triCount, triIndex, triCount # triCount = (bool) triIndex < triCount
        triCountBool = triCount
        deli triCount
    }
    // # delete all the vectors we created
    // delv xInBound
    // delv yInBound

    // # delete all the integers we created
    // deli increment
    // deli yIncrement
    // deli maxX
    // deli maxY
    // deli xV
    // deli yV

    publish





    int address = 65408
    red = 0
    ld red, address
    vec increment = 1
    sub red, red, increment
    int address = 65408
    st address, red
    deli address
    vec zero = 0
    gt red, red, zero
    delv zero
}